controller
 1 read state of resources,
 2 update resources
 3 write state to etcd 
 4 reloop
 



Kubernetes API  
1 serve the kuberntes 
   reading state: getting single objects,listing them, streaming changes 

2 manipulating state :creating updating,deleting objects 




Kind 
  objects represent a persistent entity
  Lists
  Special-purpose kinds 

API  group
  a collection of kinds that are logically related.

Version
  v1alpha1 --> v1beta1 --> v1 


GroupVersionResource  GVR 

/apis/batch/v1/namespaces/$namespace/jobs
     group  version                  resource 

/api/v1/namespaces/
/api/v1/nodes 

GroupVersionKind  GVK 
	 
	 
API resources 
kubectl api-resources 
kubect api-versions 
	 



kubernetes API Processing overview 

api http handler --> authn & authz --> mutating admission --> object schema validation -->validating admission --> persisting to etcd 
                                        mutating webhooks                                  validating webhooks 
										
1  DefaultBuildHandlerChain()    k8s.io/apiserver/pkg/server/config.go 
2 handler    k8s.io/apiserver/pkg/handler.go
3 a handler is registered for each api group 


after generic handler chain is passed, the actual request processing starts
										



										
										
Basic of client-go 
runtime.Object --> schema.ObjectKind --> metav1.TypeMeta -- Resource

k8s.io/apimachinery/pkg/runtime 
 type Object interface {
  GetObjectKind() schema.ObjectKind 
  DeepCopyObject() object
} 

k8s.io/apimachiner/pkg/runtime/schema 
 type ObjectKind interface{
   SetGroupVersionKind(kind GroupVersionKind)
   GroupVersionKind() GroupVersionKind    
}

k8s.io/apimachinery/meta/v1 
 type TypeMeta struct {
   Kind string  `json:"kind,omitempty" protobuf:"bytes,1,opt,name=kind"`
   APIVersion string `json: "apiVersion,omitempty"`
}

										
type Pod struct {
  metav1.TypeMeta `json:",inline"`
  metav1.ObjectMeta `json:"metadata,omitempty"`
  Spec PodSpec `json:"spec,omitempty"`
  Status PodStatus `json:"status,omitempty"`
}


k8s.io/apimachinery/pkg/meta/v1 
type ObjectMeta struct {
  Name string `json:"name,omitempty"`
  Namespace string `json:namespace,omitempty`
  UID types.UID `json:"uid,omitempty"`
  ResourceVersion string `json:"resourceVersion,omitempty"`
  CreationTimestamp Time `json:"creationTimestamp,omitempty"`
  DeletionTimestamp *Time `json:"deletionTimestamp,omitempty"`
  Lables map[string]string `json:"labels,omitempty"`
  Annotations map[string]string `json:"annotations,omitempty"`
  ...
}


client set main interface 

type Interface interface {
  Discovery() discovery.DiscoveryInterface
  AppsV1() appsv1.AppsV1Interface
  AppsV1beta1() appsv1beta1.AppsV1beta1Interface
  AppsV1beta2() appsv1beta2.AppsV1beta2Interface
  AuthenticationV1() authenticationv1.AuthenticationV1Interface
  AuthenticationV1beta1() authenticationV1beta1.AuthenticationV1beta1Interface 
  AuthrizationV1() authorizationv1.AuthorizationV1Interface
  AuthorizationV1beta1() authorizationbeta1.AuthorizationV1beta1Interafce 
  ...
}


Client  discovery client 

type AppsV1beta1Interface interface {
  RESTClient() rest.Interface 
  ControllerRevisionsGetter 
  DeploymentsGetter
  StatefulSetsGetter
}

RESTClient being a generic REST client, and one interface per resource 

type DeploymentsGetter interface {
  Deployments(namespace string) DeploymentInterface
}

type DeploymentInterface interface{
  Create(*v1beta1.Deployment)(*v1beta1.Deployment,error)
  Update(*v1beta.Deployment)(*v1beta1.Deployment,error)
  UpdateStatus(*v1beta1.Deployment)(*v1beta1.Deployment,error)
  Delete(name string,options *v1.DeleteOptions) error 
  DeleteCollection(options *v1.DeleteOptions,listOptions v1.ListOptions) error
  Get(name string, options v1.GetOptions)(*v1beta1.Deployment, error)
  List(opts v1.ListOptions)(*v1beta1.DeploymentList,error)
  Watch(opts v1.ListOptions)(watch.Interface,error)
  Patch(name string,pt types.PatchType, data []byte,subresources ...string)(result *v1beta1.Deployment,err error)
  DeploymentExpansion
}


status subresources: UpdateStatus 
 UpdateStatus  use an additional HTTP endpoint suffixed with /status 
 
Update /apis/apps/v1beta1/namespaces/ns/deployments/name   deployment spec 
UpdateStatus /apis/apps/v1beta1/namespaces/ns/deployments/name/status  deployment status 





Listings and Deletions 
 DeleteCollection  delete multiple objects of a namespace at once. the listOptions  parameter allows us to define which objects should be delete using a field or label selector
 
type ListOptions struct {
  ...
  LabelSelector string `json:"labelSelector,omitempty"`
  FieldSelector string `json:"fieldSelector,omitempty"`
  ...
} 
 
 
Watches 
 watch gives an event interface for all changes(adds,removes,updates) to objects.

k8s.io/apimachinery/pkg/watch 
type Interface interface {
  Stop()  //stop watching. close resultchan.
  ResultChan() <- chan Event
}


Event 
type EventType  string 

const(
  Added EventType = "ADDED"
  Modified EventType = "MODIFIED"
  Deleted  EventType = "DELETED"
  Error    EventType = "ERROR"
)


Type Event struct {
  Type EventType
  Object runtime.Object   //object is: if type is added or modified : state 
                          // if type is deleted: the state of the object immediately before deletion 
}


使用watch
Informers  首先会call List 获取所有相关objects信息缓存起来 然后watch并更新cache 能够正确处理网络问题或其他集群问题中恢复过来
  watch interface 
  cache with indexed lookup 

  

client Expansion扩展
  DeploymentExpansion empty interface   用于添加自定义client 行为
  
  
Client Options  


cfg ,err := clientcmd.BuildConfigFromFlags("",*kubeconfig)
cfg.AcceptContentTypes = "application/vnd.kubernetes.protobuf,application/json"
cfg.UserAgent = fmt.Sprintf("book-example/v1.0 (%s/%s) kubernetes/v1.0",runtime.GOOS,runtime.GOARCH)
cleintset,err := kubernetes.NewForConfig(cfg)




REST config 
 QPS 默认5s
 Burst 默认10s
 Timeout 没有默认值 但是API server 短时间运行 默认是60s   长时间运行： watch /exec /portforward /proxy
 
long-running 
  Watch,log streaming,exec,port-forward 
non-long-running 
  GET LIST UPDATE 

当k8s重启时，会等60s去优雅的关闭那些短时间运行的请求。长时间运行的请求会被切断



Informers and Caching 

Informers 
  1 informer的事件来自API server 
  2 提供类客户端LISTer接口 从内存缓存中获取列出objects
  3 为adds,removes,updates事件 注册事件处理程序
  4 用store 实现内存缓存 
  5 它们通过尝试另一个监视请求进行恢复，在不丢失任何事件的情况下获取事件流。如果中断时间很长，并且由于etcd在新的监视请求成功之前从数据库中清除了事件，API服务器丢失了事件，那么检出者将重新列出所有对象。
   relists 是注册的事件处理程序会在10minutes或30miniutes后会查看所有objects (重新同步纯粹是在内存中进行的，不会触发对服务器的调用。这在过去是不同的，但最终改变了，因为watch机制的错误行为已经得到了足够的改进，不再需要relists。)
  
informer会在API server上创建负载
application的资源应该为每个groupversionResource实例化一个informer
在一个应用中 使用工厂informer factory 来为同一个resource共享informer
 
                                           Lister <-------->  
Watch evnets(from api server) --> informer (Store DB)
                                           Informer (event handler)------->



k8s.io/client-go/informers 
eg:
import (
  ...
  "k8s.io/client-go/informers"
)
....
clientset, err := kubernetes.NewForConfig(cfg)
informerFactory := informers.NewSharedInformerFactory(clientset,time.Second*30)
podInformer := informerFactory.Core().V1().Pods()
podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
  AddFunc: func(new interface{}){...},
  UpdateFunc: func(old,new interface{}){...},
  DeleteFunc: func(obj interface{}){...}
})
informerFactory.Start(wait.NeverStop)
informerFactory.WaitForCacheSync(wait.NeverStop)
pod,err := podInformer.Lister().Pods("programing-kubenertes").Get("client-go")












































































































































































































































































































































	 
	 
	 
